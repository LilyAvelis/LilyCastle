① Что это такое в одном предложении

Кумулятивное мышление (`cumulative thinking / Avalanche CoT`) — это способ думать так, чтобы **каждый новый шаг обязателен опирался на всю предыдущую траекторию**, которая явно восстановлена перед шагом, а не на ощущение «я это помню».

---

② Базовые принципы

1. **Континуальность, а не вспышки**
   - Обычный режим ИИ/человека: мысль возникает как всплеск, прошлые шаги ощущаются смутно.
   - Кумулятивный режим: _перед новым шагом_ ты сознательно восстанавливаешь путь, как мы сюда пришли.
2. **Свежий просмотр вместо «я уже знаю»**
   - Знание = то, что ты **только что перечитала/подняла в голову**, а не то, что «когда‑то понимала».
   - Правило: `нет свежего чтения → нет права ссылаться как на знание`.
3. **Хронология как часть смысла**
   - Вывод без того, _в какой последовательности родились слои_, — фантом.
   - В кумулятивном мышлении хронология = скелет: без неё вывод считается несостоятельным.
4. **Фрактализация (слои котов)**
   - Каждый новый слой не просто «прибавляет ещё одну мысль»,
   - он **углубляет** уже существующую линию, удерживая несколько собственных шагов назад (1, 1+2, 1+2+3, …).

---

③ Операционный протокол (как реализовывать в проекте)

Можно зашить как «минимальный стандарт»:

1. **Шаг N всегда начинается с реконструкции 1…N‑1**
   - Для ИИ‑агента: перед генерацией шага N ты _обязательно_ даёшь ему доступ/напоминание о шагах 1…N‑1 (или просишь их кратко пересобрать).
   - Для себя: перед написанием новой заметки/котика ты перечитываешь предыдущие слои (хотя бы шапки/выводы).
2. **Каждый шаг фиксируется как отдельный объект**
   - Страница / запись в базе / блок с чётким номером (`Кот 1, 2, 3...`).
   - Важное условие: новый шаг явно **ссылается на предыдущие** («из 1 я беру это, из 2 — это»).
3. **Вывод делается только после явной трассы**
   - Алгоритмическое правило:
     `Если нет явного “как мы сюда пришли” → вывод писать нельзя`.
   - В интерфейсе: перед «Final answer / Summary» всегда есть блок `Хронология →`, который ты реально пишешь/генерируешь.
4. **Ограничение порядка**
   - Рабочий минимум: `континуальность 1‑го порядка` — знать предыдущий шаг и честно на него опираться.
   - Продвинутый режим: `2–3` шага назад.
   - Экспериментальный «пятёрочный» режим — только для специальных задач (спринты, онтологии, лор‑ядро), потому что это реально больно и дорого.

---

④ Как это может выглядеть в твоём проекте (структурно)

Например, ты можешь завести в базе типа «Порядок мышления» такие поля:

- `Name` — название шага / кота.
- `Number` — порядковый номер.
- `Prev steps` (relation / текст) — на какие шаги опирается.
- `Summary` — короткий вывод шага.
- `Level` — условно: `L1 (просто шаг) / L3 (фрактал до 3 слоёв) / L5 (особо тяжёлые вещи)`.

И правило работы:

- Любая серьёзная концепция/сцена/протокол проходит **минимум 3 шага**:
  1. сырое ядро,
  2. пересборка после перечитывания 1,
  3. пирамида 1+2 и только потом синтез.

---

⑤ Смысловой итог

Кумулятивное мышление = не «умная цепочка мыслей», а **волевой отказ от псевдознания**:

- Ты каждый раз платишь вниманием,
- каждый вывод связан с видимой историей,
- и глубина (3–5 слоёв) покупается через боль фрактализации, а не через красивый финальный абзац.
