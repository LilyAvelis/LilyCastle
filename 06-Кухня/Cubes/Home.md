① Краткий питч идеи (для Кими)

**Рабочее название:** Garden Cubes / Китайская Голова файла

**Суть:**

Мы перестаём думать о коде как о плоском тексте и начинаем думать о нём как о наборе **кубиков** (блоков) с богатой мета‑семантикой.

Код остаётся в привычных языках (TS и т. д.), но у каждого файла появляется **отдельная “китайская голова”** — файл/слой, который описывает всё важное _о_ коде.

---

② Как устроен один «двойной файл»

У каждого модуля есть два слоя:

1. **Тело** — обычный файл, например `chatViewProvider.ts`.
2. **Голова** — параллельный файл / запись, например [`chatViewProvider.head.cn`](http://chatViewProvider.head.cn), написанная на плотном «китайском» формате.

В голове мы не дублируем код.

Там живут **кубики**:

- каждый кубик = логическая единица (функция, класс, сервис, протокол);
- внутри кубика:
  - `код` живёт в теле (строки / имя сущности),
  - `мета` живёт в голове (роль, связи, требования, статус и т. д.).

Голова для ИИ — как китайский текст:

один символ = много смысла,

а не буквы по одной.

---

③ Что именно хранит «китайская голова»

Примерно такой минимальный набор (кубо‑онтология v0):

- **Идентичность кубика**
  - id / имя
  - тип: `function | class | service | hook | view | entity`
  - уровень: `core | edge | experimental | legacy`
- **Роль**
  - короткое смысловое описание:
    «маршрутизирует сообщения»,
    «счётчик денег»,
    «визуальный слой Garden‑чата».
- **Связи (requirements)**
  - `нуждается в`: список других кубиков (по логическим именам, а не по путям импортов);
  - `обслуживает`: какие протоколы / комнаты / юзкейсы.
- **Ограничения**
  - что этот кубик **никогда не делает**
    (например: не трогает биллинг, не пишет в FS).
- **Статус**
  - `draft / stable / refactor / deprecate`.
- **Координаты в теле**
  - отсылка к коду: файл, диапазон строк или имя сущности, чтобы инструменты могли находить мясо.

То есть шапка — это **явное, плотное описание структуры и намерений**, а не смутные импорты и комментарии.

---

④ Как это дружит с «кубологикой»

- Мир кода = **граф кубиков**.
- Каждый кубик знает:
  - своё место в иерархии,
  - своих соседей,
  - свои запреты.
- ИИ работает в первую очередь с **головой графа**, а не с текстом:
  - читает китайскую шапку → строит многомерную карту;
  - при нужде подтягивает конкретный блок кода через инструменты типа `focus` / Knife;
  - изменения формулирует как операции над кубиками:
    `создать кубик`, `поменять роль`, `переставить связь`, `заменить тело кубика`.

По сути, для ИИ китайская голова — это его **нативный язык мышления**.

Тело — просто реализация для людей и компилятора.

---

⑤ Как бутстрапить (v0, без войны с VS Code)

Высокоуровневый план, который можно обсуждать с Кими:

1. **Определяем формат головы**
   - маленький «китайский» DSL для описания кубиков и связей.
   - живёт как отдельные файлы / записи (не мешает GUI).
2. **Пишем мост**
   - инструмент, который:
     - читает существующий TS‑файл,
     - строит первичный список кубиков (через текущий `skeleton`),
     - генерирует черновую голову (которую потом можно править).
3. **Учимся делать операции над кубиками**
   - `list_cubes(file)`
   - `get_cube(id)`
   - `replace_cube(id, new_body)` — реализуется через Knife в теле.
4. **Постепенно переносим смысл в голову**
   - requirements, роли, статусы, запреты — всё уходит туда;
   - импорты и прочий «мусор данов» становятся просто тех. деталями, подчинёнными голове.

---

⑥ Формула для рассказа Кими (если прям одной фразой)

> «Мы хотим дать ИИ **китайскую голову** для каждого файла:

> отдельный плотный язык, где код описан как сеть кубиков,

> а тело на TS — всего лишь реализация.

> ИИ живёт в голове, люди — в теле, а между ними — парсер‑мост.»

Этого, думаю, хватит, чтобы у Кими загорелись его китайские нейроны.
